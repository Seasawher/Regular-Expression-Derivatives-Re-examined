## 5 経験
私たちは、RE-導関数ベースのスキャナジェネレータの2つの独立した実装で経験があります。シカゴ大学で開発されたSMLスキャナジェネレータであるml-ulexと、PLT Schemeスキャナジェネレータです。これらのツールはどちらも拡張REをサポートしており、定期的に使用されています。

### 5.1 拡張RE
RE言語に補集合演算子を含めることで、自然で簡潔な仕様を表現する能力が向上します。例えば、次のREはCスタイルのコメントに一致します。コメントは「/」シーケンスで開始され、最初に続く「/」シーケンスで終了します（コメント内のコメント開始シーケンスは無視されます。つまり、これらのコメントはネストしません）:
/¬(Σ∗/Σ∗)/
内部のRE「(Σ∗/Σ∗)」はコメント終了シーケンス「/」を含む文字列を表し、その否定はコメント終了シーケンスを含まない文字列を表します。したがって、全体のREはコメント開始シーケンスで始まり、最後の2つの要素としてコメント終了シーケンスを含まない文字列を表します。補集合演算子なしでこのパターンを表現するのはより面倒です:
/((Σ \ { })∗(ε + ∗(Σ \ { /,  })))∗/
REのブール演算の一般的な使用法の1つは、REの減算、すなわちr & ¬sを使用してL[[ r]] \ L [[ s]]の文字列を表すことです。例えば、DrSchemeプログラミング環境（Findler et al., 2002）は、誤ったレキシカル単位を赤で強調表示します。これらのレキシカル単位を検出するために、次のREを使用します:
(idchar)+ & ¬(identifier + number)
ここで、idcharは識別子に現れる可能性のある文字の集合を表し、identifierは有効な識別子に一致するRE、numberは数値リテラルに一致するREです。‘&’の左側のREはすべての潜在的な誤った識別子を含みますが、有効な文字列（有効な識別子や数値など）も含みます。誤った識別子だけに一致させるために、有効な識別子や数値を減算します。この例では、REの減算イディオムにより、無効なレキシカル単位だけの正の定義を考案する必要がなくなります。このような定義は、PLT Schemeのレキシカル構文の性質上、非常に複雑になります。例えば、識別子は#文字で始まることができますが、特定の文字列の1つが直後に続く場合に限ります。

### 5.2 DFAのサイズ
私たちの経験では、RE導関数を使用することはREから認識器を生成する簡単な方法です。また、RE導関数を使用することで、lexやml-lex（Appel et al., 1994）などのツールが使用するアルゴリズムよりも小さな状態機械が生成されることがわかりました。ml-lexツールで生成された状態機械のサイズを、新しいml-ulexツールで生成されたものと比較しました。また、ml-ulexで生成された状態機械にDFA最小化アルゴリズムを実行しました。テストケースとして、さまざまな言語の14の既存のml-lex仕様を使用しました。結果は表1に示されています。ほとんどの場合、RE導関数法はより小さな状態機械を生成しました。ほとんどの場合、差は小さいですが、2つのケース（SchemeとRusso）では、ml-ulex DFAは3分の1少ない状態を持っています。さらに、ml-ulexはRussoを除くすべての例で最小状態機械を生成しました。RussoではDFAが最適より4％大きく、L2ではDFAが39％大きいです。これらのケースでは、ml-lexは大幅に悪い結果を示しました。

### 5.3 文字クラスの有効性
また、上記のレキサ仕様を使用して、文字クラスの有用性を測定しました。n個の状態とm個の異なる状態遷移を持つDFAの場合、少なくともm個、最大でn|Σ|個の導関数を計算する必要があります。ml-ulexに計算された異なる状態遷移の数と、アルゴリズムによって計算されたおおよその文字クラスの数をカウントするように計器を設置しました。SchemeとL2の2つのケースを除いて、近似は完璧でした。近似が完璧でなかった2つのケースでは、アルゴリズムは必要以上に5.4％と6.2％多くの導関数を計算しました。さらに印象的なのは、計算を避けた導関数の数です。入力アルファベットとして7ビットのASCII文字セットを仮定すると、アルゴリズムは可能な導関数の2％〜4％しか計算しません。したがって、文字クラスは、基礎となるアルファベットが小さい場合でも、DFAの構築において大きな利益を提供すると結論付けました。