## 4 実用的なDFA構築

図1に示されているアルゴリズムはシンプルですが、効率的な実装を構築するためには以下の3つの問題に対処する必要があります：
1. goto関数でq′ ≡ qcをテストするために使用される、2つのREが等価であるかどうかを決定する問題は高コストです。実際、交差および補集合演算子を含むREの言語等価性を決定することは非初等的な複雑性を持ちます（Aho et al., 1974）。
2. δ関数を計算するためにΣのシンボルを反復することは、大きなアルファベットに対しては実用的ではありません。（例えば、Unicode文字セットには110万以上のコードポイントがあります。）
3. スキャナジェネレータは通常、REのコレクションを入力仕様として受け取りますが、図1のアルゴリズムは単一のREに対してDFAを構築します。
これらの問題は次の3つの小節で対処されます。

### 4.1 弱いRE等価性の概念

図1のDFA構築アルゴリズムは、等価な状態が存在しない場合にのみ新しい状態を導入します。Brzozowski（1964）は、この状態等価性のチェックがアルゴリズムによって生成されるDFAの最小性を保証することを証明しましたが、RE等価性のチェックは高コストです。したがって、実際にはテストを次のように変更します：
∃q′ ∈ Q そのような q′ ≈ qc
ここで、≈は次のように定義されるRE等価性の近似です：

#### 定義 4.1
≈を次の方程式を含むRE上の最小の関係とします：
r & r ≈ r
r & s ≈ s & r
(r & s) & t ≈ r & ( s & t)
∅ & r ≈ ∅
¬∅ & r ≈ r
(r · s) · t ≈ r · (s · t)
∅ · r ≈ ∅
r · ∅ ≈ ∅
ε · r ≈ r
r · ε ≈ r
(∗) r + r ≈ r
(∗) r + s ≈ s + r
(∗) ( r + s) + t ≈ r + ( s + t)
¬∅ + r ≈ ¬∅
∅ + r ≈ r
(r∗)∗ ≈ r∗
ε∗ ≈ ε
∅∗ ≈ ε
¬(¬r) ≈ r
2つのRE rとsは、r ≈ sの場合に類似し、そうでない場合に非類似とします。

#### 定理 4.1
もしr ≈ sならば、r ≡ sです。つまり、類似したREは等価です。

証明
類似性を定義する規則に基づく帰納法によります。非帰納的なケースは、定義2.2の単純な代数的帰結です。 

Brzozowski（1964）は、上記の(∗)でマークされた規則のみを含むREの類似性の概念が、すべてのREが有限数の非類似な導関数しか持たないことを保証するのに十分であることを証明しました。したがって、類似性を等価性の近似として使用すれば、DFA構築は終了することが保証されます。我々の経験では、マークされた規則のみを含めると非常に大きな機械が生成されますが、完全なセットを使用するとほとんどの場合最小の機械が得られます（セクション5参照）。

我々の実装では、すべてのREが≈-標準形であるという不変条件を維持し、構造的等価性を使用して等価なREを識別します。この不変条件を確保するために、REを抽象型として表現し、スマートコンストラクタ関数を使用して≈-標準形を構築します。各RE演算子には、≈方程式の適用可能性をチェックする関連するスマートコンストラクタ関数があります。方程式が適用される場合、スマートコンストラクタは方程式を左から右への簡約として使用してREを簡略化します。例えば、否定のコンストラクタはその引数を調べ、もしそれが( ¬r)の形であれば、コンストラクタは単にrを返します。

交換律および結合法則の方程式については、これらの等価性を使用して部分項を辞書順にソートします。また、この辞書順を使用してREキーを持つ関数的有限マップを実装します。このマップは、図1のDFA状態の集合Qの表現として使用され、REラベルが状態にマップされます。メンバーシップテストqc ∈ Qは有限マップのルックアップに過ぎません。

### 4.2 文字セット

従来のDFA構築アルゴリズム（Aho et al., 1986）の提示にはアルファベットΣの反復が含まれ、図1の導関数ベースのアルゴリズムも同様です。Σの反復は小さなアルファベット、例えばASCII文字セットに対しては効率的ですが、Unicode（Unicode Consortium, 2003）のような大きなアルファベットに対しては実用的ではありません。任意の状態の出次数は通常アルファベットのサイズよりもはるかに小さいため、状態遷移に文字セットをラベル付けすることが有利です。このセクションでは、与えられた状態からの遷移を決定する際に計算する必要のある導関数の数を大幅に削減するために、文字セットを使用するBrzozowski（1964）の研究の拡張について説明します。

最初のステップは、REの抽象構文を次のように再定式化することです：
r, s ::= S ここで S ⊆ Σ
| ε 空文字列
| r · s 連結
| r∗ クリーン閉包
| r + s 論理和（選択）
| r & s 論理積
| ¬ r 補集合

Sは定義2.1の空集合および単一文字のケース、ならびに文字クラスをカバーします。セクション2および3の定義は自然に文字セットに拡張されます：
L[[ S]] = S
ν(S) = ∅
∂a S =
{ε a ∈ S
∅ a ©
∈ S

前述のように、我々の実装では文字セットを含むREを標準化するために簡略化を使用します。
R + S ≈ T ここで T = R ∪ S
¬S ≈ T ここで T = Σ \ S
R, S, Tは文字セットを表します。

前述のように、DFAの与えられた状態qは通常、Σのシンボル数よりもはるかに少ない異なる出力状態遷移を持ちます。S1, . . . , S nをΣの分割とし、a, b ∈ Siの場合、δ(q, a) = δ(q, b)（同様に∂a q ≈ ∂b q）であるとします。もしqのために事前に分割S1, . . . , S nを知っていれば、qからの遷移を計算する際に各Siごとに1つの導関数を計算するだけで済みます。導関数が異なる場合、分割は最小です。この最後の状況は次の定義によって説明されます：

#### 定義 4.2
Σ上のRE rとシンボルa, b ∈ Σが与えられたとき、a r bは∂a r ≡ ∂b rの場合にのみ成り立ちます。rの導関数クラスはΣ/rの同値クラスです。aによって表されるrの導関数クラスを[a]r = {b | a r b}と書きます。

例えば、a + b · a + cの導関数クラスは{a, c}, {b}およびΣ \ { a, b, c}です。

2つのシンボルが2つのREに対して同じ導関数クラスに属する場合、それらのシンボルは任意のREの組み合わせに対しても同じ導関数クラスに属します。この洞察は次の補題によって形式化されます：

#### 補題 4.1
RE rとs、およびシンボルaとbが与えられ、a r bおよびa s bであるとします。次の方程式が成り立ちます：
- a (r·s) b
- a (r+s) b
- a (r&s) b
- a r∗ b
- a ¬r b

証明
証明は単純な方程式推論に基づきます。例えば
∂a (r · s) ≡ ∂a r · s + ν(r) · ∂a s
≡ ∂b r · s + ν(r) · ∂b s
≡ ∂b (r · s)
したがって、a (r·s) bです。他の方程式も同様に従います。 

各状態の導関数クラスを導関数を見つける前に決定することもできますが、一般的には|Σ|の作業を行わずにそれらを計算することはできません。代わりに、構造的再帰によって導関数クラスの近似を計算する関数C : RE → 22Σを定義します。原子的なREに対して、Cは正確な結果を返します：
C() = {Σ}
C(S) = {S, Σ \ S}
しかし、複合REはやや厄介です。補題4.1はガイダンスを提供します：aとbがC(r)およびC(s)の両方で関連している場合、それらはC(r + s)などでも関連しているべきです。我々のアルゴリズムは保守的であり、C(r)およびC(s)の両方で関連しているシンボルのみがC(r + s)で関連していると仮定します。これは次の表記法によって指定されます：
C(r) ∧ C(s) = {Sr ∩ S s | S r ∈ C(r), Ss ∈ C(s)}

残りのケースを次のように定義できます：
C(r · s) =
{C(r) r is not nullable
C(r) ∧ C(s) otherwise
C(r + s) = C(r) ∧ C(s)
C(r & s) = C(r) ∧ C(s)
C(r∗) = C(r)
C(¬r) = C(r)

再び例a + b · a + cを考えます：
C((a + b · a) + c) = C(a + b · a) ∧ C(c)
= ( C(a) ∧ C(b · a)) ∧ C(c)
= ( C(a) ∧ C(b)) ∧ C(c)
= ( {{a}, Σ \ { a}} ∧ {{b}, Σ \ { b}}) ∧ {{ c}, Σ \ { c}}
= {∅, {a}, {b}, Σ \ { a, b}} ∧ {{c}, Σ \ { c}}
= {∅, {a}, {b}, {c}, Σ \ { a, b, c}}

前述のように、このREの正確な導関数クラスは{a, c}, {b}およびΣ\{a, b, c}であり、近似はアルファベットを過剰に分割しています。それにもかかわらず、5つのシンボルセットに考慮を減らし、各セットごとに1つの導関数を計算するだけで済みます。

導関数クラスの近似の正確性を証明するのは簡単です。

#### 定理 4.2
RE rが与えられたとき、すべてのS ∈ C(r)およびa ∈ Sに対して、S ⊆ [a]rです。

証明
補題4.1を使用して、rの構造に基づく帰納法によります。 

導関数クラスの近似を使用して、近似クラスごとに1つの導関数のみを計算するようにDFA構築アルゴリズムを修正できます。このアルゴリズムのバージョンは図3に示されています。

### 4.3 正規ベクトル

このDFA構築アルゴリズムをスキャナジェネレータで使用するためには、複数のREを並行して処理できるように拡張する必要があります。Brzozowski（1964）はこの問題を認識し、正規ベクトルをエレガントな解決策として導入しました。

#### 定義 4.3
REのn-タプル、R = ( r1, . . . , r n)を正規ベクトルと呼びます。

DFA状態にREをラベル付けする代わりに、正規ベクトルでラベル付けします。遷移関数は依然として導関数関数であり、正規ベクトルの導関数は成分ごとに定義されます：
∂a (r1, . . . , r n) = ( ∂a r1, . . . , ∂ a rn)

受理状態およびエラー状態の定義も修正する必要があります。状態は、その正規ベクトルにヌル可能なREが含まれている場合に受理状態です。エラー状態は、すべての成分が空言語∅に等しい正規ベクトルです。最後に、正規ベクトルの導関数クラスをその成分の近似導関数クラスを交差させることによって近似できます：
C(r1, . . . , r n) = ∧C(ri)