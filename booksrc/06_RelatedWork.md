## 6 関連作業
REの導関数は、XML検証タスクにおいて（オートマトンを構築せずに）オンザフライでREマッチングを行うために時折使用されてきました（English, 1999; Schmidt, 2002）。私たちのシステム以外にも、DFA構築において導関数が使用された例が少なくとも2つあります。最初の2つのEsterel言語のバージョンは導関数を使用していましたが、1987年にメモリ集約的すぎるためにこのアプローチは放棄されました（Berry, 1999）。さらに、REとDFAは字句解析には使用されていませんでした。最近では、SenとRoşu（2003）がプログラムトレースモニタリングのためにDFAを構築するためにREの導関数を使用しました。彼らのシステムは、円環的共誘導と呼ばれる技術を使用して完全なRE同値性をテストすることによって最小のDFAを生成します。このアプローチは、私たちのシステムの近似同値性テストよりも実用的ではないようです。例えば、彼らは前のセクションで言及されたL2 REの最適なDFAを計算するのに18分かかったと報告していますが、ml-ulexは最適なマシンよりも40％多い状態を持つDFAを1秒未満で計算します。彼らのアプローチの遅さは、彼らの方法が書き換えに基づいているためかもしれません。この例に状態最小化を適用しても、ml-ulexは最適なDFAを構築するのに1秒未満です。
導関数はスキャニング文献ではほとんど無視されてきました。例外の一つは、DFA構築のための導関数ベースのアルゴリズムがMcNaughtonとYamada、別名ドラゴンブックのアルゴリズム（McNaughton & Yamada, 1960）を導出する方法を示すBerryとSethi（1986）の論文です。彼らの作業とBrzozowski（1964）の導関数アルゴリズムの主な違いは、REの各シンボルに一意の添え字を付けることです。これらの添え字により、Brzozowski（1964）のアルゴリズムが統合する状態が区別されることが図4に示されています。Ken Thompsonは、REマッチングに関する彼の重要な論文（Thompson, 1968）で次のように述べています：
Brzozowskiの用語では、このアルゴリズムは検索されるテキストに対して与えられた正規表現の左導関数を継続的に取ります。
この主張は、シンボルの出現が区別されるようにマークされたREの導関数を計算している場合には真実ですが、Brzozowski（1964）のアルゴリズムを使用している場合にはそうではありません。再び、図4の例を使用してこの違いを説明できます。
BerryとSethi（1986）は、非マーキングホモモルフィズムがREの補集合と交差と可換でないことを観察しました。そのため、マークされたシンボルに基づくアルゴリズム（例：ドラゴンブックアルゴリズム）は、これらの操作をサポートするように簡単に修正することはできません。一方、DFAの補集合は簡単に計算できるため、標準のNFAからDFAへの構築はREの補集合をサポートするように拡張できます。アルゴリズムが補集合RE ¬rに遭遇すると、通常通りにrのNFAを構築し、次にNFAをDFAに変換し、それを単純に補集合にしてNFAに戻すことができます。その後、アルゴリズムは通常通りに進行します。DMSシステムのレキサジェネレータ（Baxter et al., 2004）は、まさにこの方法で補集合をサポートしています。他の補集合演算子をサポートするレキサジェネレータは知られていません。

## 7 結論
この論文では、REの導関数を紹介しました。これは古いがほとんど忘れられている技術で、REから直接DFAを構築するものです。私たちの経験では、REの導関数はREからスキャナを生成するための優れた技術であり、すべてのプログラマのツールキットに含まれるべきです。具体的には、REの導関数には以下の利点があります：
- 関数型言語での実装に適した直接的なREからDFAへの変換を提供します。
- 拡張REをほぼ無料でサポートします。
- 生成されたスキャナは、状態数においてしばしば最適であり、以前のツールによって生成されたものよりも一様に優れています。
基本的なREからDFAへのアルゴリズムを紹介することに加えて、REの導関数に基づくスキャナジェネレータの実装に関連する多くの実用的な問題についても議論しました。これには、大規模な文字セットのサポートが含まれます。