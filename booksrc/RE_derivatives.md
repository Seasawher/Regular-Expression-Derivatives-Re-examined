# 3 正規表現の微分

この節では、正規表現の微分を紹介し、それらを用いて正規表現から直接DFAを構築する方法を示します。

## 3.1 微分

微分の概念はあらゆる言語に適用できます。直感的に言えば、言語 L ⊆ Σ∗ の記号 a ∈ Σ に関する微分は、L において先頭記号 a を持つ文字列の接尾辞のみを含む言語です。

**定義 3.1**
言語 L ⊆ Σ∗ の文字列 u ∈ Σ∗ に関する微分は以下のように定義されます：
∂u L = {v | u · v ∈ L}

例えば、正規表現 r = ab∗ で定義される言語を考えます。a に関する r の微分は b∗ であり、b に関する微分は空集合です。

微分はスキャナ構築において有用です。その理由の一つは、正規言語が微分演算の下で閉じているためです。これは次の定理で述べられています：

**定理 3.1**
L ⊆ Σ∗ が正規であれば、すべての文字列 u ∈ Σ∗ に対して ∂uL も正規である。

**証明**
まず、任意の a ∈ Σ に対して、言語 ∂aL が正規であることを示します。〈Q, q0, F, δ〉 を正規言語 L を受理するDFAとします。このとき、∂aL を認識するDFAは次のように構築できます：δ(q0, a) が定義されているならば、〈Q, δ(q0, a), F, δ〉 は ∂aL を認識するDFAとなり、したがって ∂aL は正規です。そうでなければ ∂aL = ∅ となり、これも正規です。文字列に関する結果は帰納法によって導かれます。

正規表現として表現される正規言語の場合、微分を別の正規表現として計算する自然なアルゴリズムがあります。まず、正規表現から正規表現への補助関数 ν が必要です。正規表現 r が可空（nullable）であるとは、それが定義する言語が空文字列を含む場合、つまり ε ∈ L[[ r]] の場合を言います。ν 関数は以下の性質を持ちます：

ν(r) =
{ε (r が可空の場合)
∅ (それ以外の場合)

そして次のように定義されます：

ν(ε) = ε
ν(a) = ∅
ν(∅) = ∅
ν(r · s) = ν(r) & ν(s)
ν(r + s) = ν(r) + ν(s)
ν(r∗) = ε
ν(r & s) = ν(r) & ν(s)
ν(¬r) =
{ε (ν(r) = ∅ の場合)
∅ (ν(r) = ε の場合)

以下のルールは、Brzozowski (1964) によるもので、記号 a に関する正規表現の微分を計算します：

∂a ε = ∅
∂a a = ε
∂a b = ∅ (b ≠ a の場合)
∂a ∅ = ∅
∂a (r · s) = ∂a r · s + ν(r) · ∂a s
∂a (r∗) = ∂a r · r∗
∂a (r + s) = ∂a r + ∂a s
∂a (r & s) = ∂a r & ∂a s
∂a (¬r) = ¬(∂a r)

これらのルールは文字列に対して以下のように拡張されます：

∂ε r = r
∂ua r = ∂a (∂u r)

## 3.2 正規表現マッチングのための微分の利用

正規表現 r と文字列 u が与えられ、u ∈ L[[ r]] を判定したいとします。u ∈ L[[ r]] は、ε ∈ L[[ ∂u r]] である場合に限り成立し、これは ε = ν(∂u r) の場合に限り真となります。この事実と ∂u の定義を組み合わせることで、u ∈ L[[ r]] をテストするアルゴリズムが得られます。このアルゴリズムを関係 r ∼ u（r は文字列 u にマッチする）として表現します。これは以下を満たす最小の関係として定義されます：

r ∼ ε ⇔ ν(r) = ε
r ∼ a · w ⇔ ∂a r ∼ w

r ∼ u であるのは u ∈ L[[ r]] である場合に限ることは容易に証明できます。

正規表現が文字列にマッチするとき、文字列の各文字に対して微分を計算することに注目してください。例えば、a · b∗ ∼ abb の導出は次のようになります：

a · b∗ ∼ abb ⇔ ∂a a · b∗ ∼ bb
⇔ b∗ ∼ bb
⇔ ∂b b∗ ∼ b
⇔ b∗ ∼ b
⇔ ∂b b∗ ∼ ε
⇔ b∗ ∼ ε
⇔ ν(b∗) = ε

正規表現が文字列にマッチしない場合、正規表現 ∅ という微分に到達して停止します。例えば：

a · b∗ ∼ aba ⇔ ∂a a · b∗ ∼ ba
⇔ b∗ ∼ ba
⇔ ∂b b∗ ∼ a
⇔ b∗ ∼ a
⇔ ∂a b∗ ∼ ε
⇔ ∅ ∼ ε
⇔ ν(∅) = ε (偽)

## 3.3 DFA構築のための微分の利用

DFA構築の説明の前に、もう一つの定義が必要です。

**定義 3.2**
r と s が同値であるとは、L[[ r]] = L[[ s]] であることを意味し、r ≡ s と表記します。[ r]≡ は {s | r ≡ s} を表し、≡ の下での r の同値類です。

例えば a + b ≡ b + a です。

マッチング関係は、文字列内の連続する文字に対して正規表現の連続した微分を計算することで、文字列が正規表現にマッチするかテストするアルゴリズムを提供します。各ステップでは、残りの文字列にマッチしなければならない残差正規表現があります。微分をその場で計算する代わりに、Σ の各記号に対する微分を事前に計算すれば、正規表現の言語に対するDFA認識機を構築できます。DFAの状態は正規表現の同値類であり、遷移関数はそれらの類に対する微分関数です：δ(q, [a]≡) = [ ∂a (q)]≡。同値な正規表現の微分は同値であるため、この関数は適切に定義されています。DFAを構築する際、各状態にその同値類を表す正規表現でラベル付けします。受理状態は可空な正規表現でラベル付けされた状態であり、エラー状態は ∅ でラベル付けされます。このアルゴリズムを実用的にするための主な課題は、正規表現の同値性を効率的にテストする方法を開発することです。この点については次のセクションで取り上げます。

図1は、微分を使用してDFA 〈Q, q0, F, δ〉 を構築する完全なアルゴリズムを示しています。goto関数は、記号cが現れたときの状態qからの遷移を構築し、explore関数は状態qからの可能なすべての遷移を収集します。これらの関数は一緒に、DFAの状態グラフの深さ優先探索を行いながらそれを構築します。qcが新しい状態かどうかを確認するときに正規表現の同値性をテストすることに注意してください。Brzozowski (1964) は、正規表現が有限個の微分（正規表現の同値性まで）しか持たないことを証明しており、これによりアルゴリズムの終了が保証されます。(Q, δ) ペアで表される状態グラフが構築されると、受理状態を計算してDFAの4項組を構築するのは簡単です。

## 3.4 例

アルファベット {a, b, c} 上の正規表現 a · b + a · c を考えます。この正規表現のDFA構築は q0 = ∂ε (a · b + a · c) = a · b + a · c から始まり、以下のように進みます：

1. ∂a q0 = ∂a (a · b + a · c) = b + c を計算し、これは新しいので q1 と呼びます；
2. ∂a q1 = ∂a (b + c) = ∅ を計算し、これは新しいので q2 と呼びます；
3. ∂a q2 = ∂a ∅ = ∅ = q2 を計算します；
4. 同様に ∂b q2 = q2 および ∂c q2 = q2 となります；
5. ∂b q1 = ∂b (b + c) = (ε + ∅) ≡ ε を計算し、これは新しいので q3 と呼びます；
6. ∂a q3 = ∂a ε = ∅ = q2 を計算します；
7. 同様に ∂b q3 = q2 および ∂c q3 = q2 となります；
8. ∂c q1 = ∂c (b + c) = (∅ + ε) ≡ ε = q3 を計算します；
9. ∂b q0 = ∂b (a · b + a · c) = ∅ = q2 を計算します；
10. ∂c q0 = ∂c (a · b + a · c) = ∅ = q2 を計算します。

ν(q3) = ε なので、q3 は受理状態であることに注意してください。図2は、結果のDFAをグラフィカルな形式で示しています。
